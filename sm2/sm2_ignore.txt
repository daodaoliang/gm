package sm2

import (
	"crypto"
//	"crypto/aes"
//	"crypto/cipher"
	"encoding/asn1"
	"errors"
	"fmt"
	"io"
	"math/big"
	"github.com/terasum/gm/common"
	"github.com/terasum/gm/sm2/sm2p256v1"
)



// A invertible implements fast inverse mod Curve.Params().N
type invertible interface {
	// Inverse returns the inverse of k in GF(P)
	Inverse(k *big.Int) *big.Int
}

// combinedMult implements fast multiplication S1*g + S2*p (g - generator, p - arbitrary point)
type combinedMult interface {
	CombinedMult(bigX, bigY *big.Int, baseScalar, scalar []byte) (x, y *big.Int)
}

const (
	aesIV = "IV for ECDSA CTR"
)

// Public returns the public key corresponding to priv.
func (priv *PrivateKey) Public() *PublicKey {
	return &priv.PublicKey
}

// Sign signs msg with priv, reading randomness from rand. This method is
// intended to support keys where the private part is kept in, for example, a
// hardware module. Common uses should use the Sign function in this package
// directly.
func (priv *PrivateKey) Sign(rand io.Reader, msg []byte, opts crypto.SignerOpts) ([]byte, error) {
	r, s, err := Sign(rand, priv, msg)
	if err != nil {
		return nil, err
	}

	return asn1.Marshal(sm2Signature{r, s})
}

var one = new(big.Int).SetInt64(1)

// randFieldElement returns a random element of the field underlying the given
// curve using the procedure given in [NSA] A.2.1.
func randFieldElement(c sm2p256v1.SM2Curve, rand io.Reader) (k *big.Int, err error) {
	params := c.Params()
	b := make([]byte, params.BitSize/8+8)
	_, err = io.ReadFull(rand, b)
	if err != nil {
		return
	}

	k = new(big.Int).SetBytes(b)
	n := new(big.Int).Sub(params.N, one)
	k.Mod(k, n)
	k.Add(k, one)
	return
}

func randFieldElementFromByte(c sm2p256v1.SM2Curve, b []byte) (k *big.Int, err error) {
	params := c.Params()
	k = new(big.Int).SetBytes(b)
	n := new(big.Int).Sub(params.N, one)
	k.Mod(k, n)
	k.Add(k, one)
	return
}
// GenerateKey generates a public and private key pair.
// this can ensure generate key is valid
func GenerateKey(c sm2p256v1.SM2Curve, rand io.Reader) (*PrivateKey, error) {
	k, err := randFieldElement(c, rand)
	if err != nil {
		return nil, err
	}

	priv := new(PrivateKey)
	priv.PublicKey.SM2Curve = c
	priv.D = k
	priv.PublicKey.X, priv.PublicKey.Y = c.ScalarBaseMult(k.Bytes())
	return priv, nil
}

// hashToInt converts a hash value to an integer. There is some disagreement
// about how this is done. [NSA] suggests that this is done in the obvious
// manner, but [SECG] truncates the hash to the bit-length of the curve order
// first. We follow [SECG] because that's what OpenSSL does. Additionally,
// OpenSSL right shifts excess bits from the number if the hash is too large
// and we mirror that too.
func hashToInt(hash []byte, c sm2p256v1.SM2Curve) *big.Int {
	orderBits := c.Params().N.BitLen()
	orderBytes := (orderBits + 7) / 8
	if len(hash) > orderBytes {
		hash = hash[:orderBytes]
	}

	ret := new(big.Int).SetBytes(hash)
	excess := len(hash)*8 - orderBits
	if excess > 0 {
		ret.Rsh(ret, uint(excess))
	}
	return ret
}

// fermatInverse calculates the inverse of k in GF(P) using Fermat's method.
// This has better constant-time properties than Euclid's method (implemented
// in math/big.Int.ModInverse) although math/big itself isn't strictly
// constant-time so it's not perfect.
func fermatInverse(k, N *big.Int) *big.Int {
	two := big.NewInt(2)
	nMinus2 := new(big.Int).Sub(N, two)
	return new(big.Int).Exp(k, nMinus2, N)
}

var errZeroParam = errors.New("zero parameter")

// Sign signs a hash (which should be the result of hashing a larger message)
// using the private key, priv. If the hash is longer than the bit-length of the
// private key's curve order, the hash will be truncated to that length.  It
// returns the signature as a pair of integers. The security of the private key
// depends on the entropy of rand.

// sm2 sign step:
// 1. get private key dA
// 2. calc the public key pA = da * G
// 3. get Za = SM3(ENLa || ID || a || b || G || pA)
// 4. get e = SM3(Za || M)
// 5. get random k
// 6. get point (x1,y1) = k * G
// 7. get r = (e + x1) mod n
// 8. get s = ((k - r * dA)/(1+dA)) mod n

func Sign(rand io.Reader, priv *PrivateKey, msg []byte) (r, s *big.Int, err error) {
	// step 1. get private key da
	// step 2. get public key pA da * G
	// step 3. get Za
	//step get e
	e := PreHandleSTAND(msg,priv.PublicKey.X.Bytes(),priv.PublicKey.Y.Bytes())
	fmt.Println("e ", common.Bytes2Hex(e))

	//get random k
	// Get min(log2(q) / 2, 256) bits of entropy from rand.
	entropylen := (priv.SM2Curve.Params().BitSize + 7) / 16
	if entropylen > 32 {
		entropylen = 32
	}
	entropy := make([]byte, entropylen)
	_, err = io.ReadFull(rand, entropy)
	if err != nil {
		return
	}
	fmt.Println(common.Bytes2Hex(entropy))

	// Initialize an SHA-512 hash context; digest ...

	//md := sha512.New()
	//md.Write(priv.D.Bytes()) // the private key,
	//md.Write(entropy)        // the entropy,
	//md.Write(hash)           // and the input hash;
	//key := md.Sum(nil)[:32]  // and compute ChopMD-256(SHA-512),
	// which is an indifferentiable MAC.

	// step 5. get ramdom k
	// Create an AES-CTR instance to use as a CSPRNG.
//	block, err := aes.NewCipher(eb)
//	if err != nil {
//		return nil, nil, err
//	}

	// Create a CSPRNG that xors a stream of zeros with
	// the output of the AES-CTR instance.
	//csprng := cipher.StreamReader{
	//	R: rand,
	//	S: cipher.NewCTR(block, []byte(aesIV)),
	//}

	// See [NSA] 3.4.1
	c := priv.PublicKey.SM2Curve
	N := c.Params().N
	// get e
	eb := hashToInt(e, c)

	if N.Sign() == 0 {
		return nil, nil, errZeroParam
	}
	var k *big.Int
	for {
		// step 7 get r
		for {
			k, err = randFieldElementFromByte(c, entropy)
			if err != nil {
				r = nil
				return
			}
			// for debug
			k,_ = k.SetString("6CB28D99385C175C94F94E934817663FC176D925DD72B727260DBAAE1FB2F96F",16)
			fmt.Println("k: ", common.Bytes2Hex(k.Bytes()))
			x1, y1 := priv.SM2Curve.ScalarBaseMult(k.Bytes())
			fmt.Println("x1: ", common.Bytes2Hex(x1.Bytes()))
			fmt.Println("y1: ", common.Bytes2Hex(y1.Bytes()))

			// r = e + x1 (mod n)
			r = new(big.Int).Add(x1, eb)
			r.Mod(r, N)
			//until the sign not equal 0
			/* check r != 0 && r + k != n */
			if r.Sign() != 0 && r.Add(r, k).Sub(r, N).Int64() != 0 {
				break
			}
		}

		//step 8. get s = ((k - r * dA)/(1+dA)) mod n
		/* s = ((1 + dA)^-1 * (k - r * dA)) mod n */
		//r * dA
		tmp1 := new(big.Int).Mul(priv.D, r)
		// k - r * dA
		tmp2 := k.Sub(k, tmp1)
		// 1 + dA
		tmp3 := new(big.Int).Add(new(big.Int).SetInt64(1), priv.D)
		// (1 + dA)^-1
		//s := tmp3.Exp(tmp3,new(big.Int).SetInt64(-1),new(big.Int).SetInt64(0))
		s = tmp3.ModInverse(tmp3, N)
		s.Mul(s, tmp2)
		s.Mod(s, N) // N != 0
		if s.Sign() != 0 {
			break
		}
	}

	return
}



// Verify verifies the signature in r, s of hash using the public key, pub. Its
// return value records whether the signature is valid.
// sm2 verify step
// 1. get public key pA
// 2. get Za = SM3(ENTLa || ID || a || b || G || pA)
// 3. e = SM3(Za || M)
// 4. t = (r+s) mod n
// 5. get point (x1',y1') = s * G + t * pA
// 6. R = (e + x1') mod n
// 7 check R == r ?

func Verify(pub *PublicKey, msg []byte, r, s *big.Int) bool {
	fmt.Println("verify------------")
	// get eb
	eb := PreHandleRecommend(msg,pub.X.Bytes(),pub.Y.Bytes())
	fmt.Println("e ", common.Bytes2Hex(eb))

	c := pub.SM2Curve
	N := c.Params().N
	// get e
	e := hashToInt(eb, c)

	// setp 3. get t  = r + s mod n
	t := s.Mul(s, r)
	t.Mod(t, N)

	//(x1',y1') = s * G + t * pA
	tmpx1, tmpy1 := pub.SM2Curve.ScalarBaseMult(s.Bytes())
	tmpx2, tmpy2 := pub.SM2Curve.ScalarMult(pub.X, pub.Y, t.Bytes())
	x1_, y1_ := pub.SM2Curve.Add(tmpx1, tmpy1, tmpx2, tmpy2)
	if x1_.Sign() == 0 && y1_.Sign() == 0 {
		return false
	}

	//R = (e + x1') mod n
	R := e.Add(e, x1_)
	R.Mod(r, N)

	//check R == r ?
	return R.Cmp(r) == 0
}

type zr struct {
	io.Reader
}

// Read replaces the contents of dst with zeros.
func (z *zr) Read(dst []byte) (n int, err error) {
	for i := range dst {
		dst[i] = 0
	}
	return len(dst), nil
}

var zeroReader = &zr{}
